Ниже идеи, которые дают реальную пользу, без раздувания UX. Сгруппировано по эффекту.

**Качество процесса**
1. **Шаблоны экспериментов** (наборы машин/рецептов/DOE‑настроек/шагов) с клонированием.
2. **Валидация перед запуском** (обязательные поля/границы параметров/конфликт рецептов).
3. **Сравнение экспериментов** (side‑by‑side summary + differences in DOE и результаты).
4. **Контроль версий отчёта** (revision history + diff ключевых метрик).
5. **Подписи/утверждения** (ролевая подпись на отчётах/шаге квалификации).

**Ускорение работы**
1. **Горячие действия**: быстрые кнопки “Create DOE”, “Add run”, “Add report” из списка.
2. **Автозаполнение из последнего эксперимента** (машина/параметры/рецептуры).
3. **Поиск + фильтры** по статусу/машине/владельцу/дате.

**Аналитика**
1. **Авто‑метки дефектов** на основе аномалий (например, threshold по давлению/весу).
2. **Единый KPI‑панель** (cycle time, weight stability, defects rate, process window width).
3. **Стабильность результатов** (временная серия на уровне run’ов).

**Данные и интеграции**
1. **Экспорт CSV/Excel** по всем сущностям (эксперимент/DOE/qualification/report).
2. **Импорт параметров машин** из шаблона (CSV + токены).
3. **Лёгкий бэкап** (кнопка “Export DB” + auto‑backup folder).

**Роли и безопасность**
1. **Мягкие права** (manager может читать, admin — редактировать).
2. **Логи действий** (кто поменял параметры/владельца/отчёт).

**UX‑детали**
1. **Статусные бейджи** везде (эксперимент/DOE/отчёт/qualification step).
2. **Inline‑редактирование** для мелких правок (имя, описание).
3. **Скелетон‑загрузка** и подсветка “что изменилось”.

## План экспорта данных

**Этап 1 — Базовый CSV (быстро дать ценность)**
1. Экспорт эксперимента: `experiment.csv` (id, name, owner, status, created_at).
2. Экспорт DOE runs: `doe_runs.csv` (run_code, recipe, inputs, outputs, tags, done, exclude).
3. Экспорт qualification: `qualification.csv` (шаги, настройки, summary, run_values).
4. Экспорт отчётов: `reports.csv` (name, executors, include, signed_by, signed_at).

**Этап 2 — Пакетный экспорт**
1. ZIP‑пакет с подкаталогами: `experiment/`, `doe/`, `qualification/`, `reports/`.
2. Внутри — CSV + `metadata.json` (ver, timestamps, user).
3. Кнопка “Export All” на уровне эксперимента.

**Этап 3 — Excel**
1. Один `.xlsx` с табами: `Experiment`, `DOE Runs`, `Qualification`, `Reports`.
2. Опционально: вкладка “Summary” с KPI.

**Этап 4 — Импорт обратно (опционально)**
1. Импорт только runs (безопасный), затем расширение до полной загрузки.

**Технические детали (коротко)**
- Сервисы: `src/services/export_service.ts`.
- Роуты: `/experiments/:id/export` + параметры `format=csv|xlsx` и `scope=...`.
- Авторизация: только admin/manager.
- Размеры: стриминг для больших CSV.

## План: мобильное приложение и синхронизация

**Цель**
- Дать работу “в поле” с телефона/планшета и не терять целостность данных между устройствами.

**Вариант A — Общее серверное приложение (рекомендуемый как основной)**
1. Оставить одну центральную БД на сервере и открыть доступ через веб/API.
2. Сделать адаптивный mobile-first интерфейс (или легкий mobile app-клиент), который работает с этим же API.
3. Все изменения сразу пишутся в центральную БД, конфликты минимальны.

**Плюсы**
- Самая простая консистентность данных.
- Нет сложной логики двусторонней синхронизации.
- Быстрее поддержка ролей, подписей, аудита.

**Минусы**
- Нужен стабильный интернет.
- Требуется нормальный серверный деплой и резервирование.

**Вариант B — Локальные базы + облачная синхронизация**
1. На локальной установке хранится своя БД.
2. Поднимается sync-механизм: журнал изменений (`change_log`) + обмен дельтами через облако.
3. При конфликте используется стратегия: “последняя правка” или ручной merge по сущности.

**Плюсы**
- Можно работать оффлайн дольше.
- Подходит для изолированных площадок.

**Минусы**
- Самая дорогая часть по разработке и тестам.
- Высокий риск конфликтов при одновременном редактировании.
- Сложнее безопасность и трассировка изменений.

**Рекомендуемая стратегия**
1. Этап 1: серверная модель (Вариант A) + адаптивный UI.
2. Этап 2: локальный offline-cache только для чтения/черновиков.
3. Этап 3: если реально нужна автономность, вводить ограниченную sync-модель для конкретных сущностей (например, tasks/notes), а не всей БД сразу.

**Минимальный технический бэклог**
1. API-слой для мобильного клиента: auth, experiments, tasks, reports, notes.
2. Токены доступа + refresh; принудительный logout/ban должен инвалидировать сессии.
3. Фоновая отправка черновиков при восстановлении сети.
4. Наблюдаемость: лог ошибок sync/API, метрики задержек и конфликтов.

## План: календарь на странице пользователя (Tasks + Notes + Reports)

**Цель**
- Сделать единый персональный календарь пользователя как центр времени: задачи, заметки, отчеты и дедлайны экспериментов в одном месте.

**Ключевой UX**
1. Отдельная страница `My Calendar` в профиле пользователя.
2. Переключение видов: `Month / Week / Day / Agenda`.
3. Цветовые типы событий:
- `Task` (оранжевый),
- `Note` (синий),
- `Report` (зеленый),
- `Experiment deadline` (красный).
4. Клик по событию открывает правую карточку с метаданными и ссылкой в сущность.
5. Фильтры в одну строку: тип события, эксперимент, автор, статус.
6. Поиск по заголовку/тексту события в header календаря.

**Технический стек (предложение)**
1. Библиотека календаря: `FullCalendar`.
2. Источник данных: агрегирующий API `GET /me/calendar/events`.
3. Формат события (нормализованный):
- `id`, `type`, `title`, `start`, `end`, `allDay`, `status`, `experiment_id`, `entity_type`, `entity_id`, `url`.
4. Таймзона: хранить в UTC, отображать в локальной TZ пользователя.

**Агрегация данных**
1. `Tasks`:
- `due_date` как основная дата,
- при наличии `started_at/completed_at` добавлять дополнительные точки истории (второй этап).
2. `Notes`:
- отображать по `updated_at` (или `created_at`, если заметка не редактировалась),
- дневные заметки должны обновлять время события при дописывании.
3. `Reports`:
- `created_at`,
- `signed_at` как отдельный тип события `Report signed` (второй этап).
4. `Experiment`:
- плановый дедлайн (если поле есть) или milestone-дата.

**Роуты и backend**
1. `GET /me/calendar` — страница календаря.
2. `GET /me/calendar/events?from=...&to=...&types=...&experiment_id=...` — JSON для FullCalendar.
3. Индексы в БД для скорости:
- по датам (`tasks.due_date`, `notes.updated_at`, `report_documents.created_at`),
- по `experiment_id`,
- по `owner_id/author_id`.

**Права доступа**
1. Пользователь видит только доступные ему сущности по текущей ролевой модели.
2. Админ/менеджер видит расширенный набор по правам проекта.
3. В API сразу применять ACL, без фильтрации только на фронте.

**Интеграция с Google Calendar (этапно)**
1. Этап 1: экспорт `.ics` по фильтрам календаря пользователя.
2. Этап 2: подключение внешнего Google Calendar в read-only.
3. Этап 3: двусторонняя синхронизация через Google API (`external_event_id`, refresh token, дедупликация).

**Этапы внедрения**
1. `MVP`:
- страница `My Calendar`,
- события `Tasks + Notes + Reports`,
- фильтры по типу и эксперименту,
- переход в исходную сущность по клику.
2. `V2`:
- `Week/Day/Agenda`,
- расширенные фильтры,
- цветовые легенды и статусные бейджи.
3. `V3`:
- интеграция Google Calendar,
- пользовательские пресеты фильтров,
- напоминания и уведомления.

**Критерии готовности (DoD)**
1. Календарь открывается < 2 сек на диапазоне 30 дней.
2. События из `tasks/notes/reports` отображаются корректно по времени и TZ.
3. Фильтры не ломают переходы и не показывают чужие данные.
4. Клик по событию всегда ведет в соответствующую сущность.
5. Экспорт `.ics` формируется корректно по выбранным фильтрам.

## План: комментарии, заметки и лабораторный журнал (MD + календарь)

**Цель**
- Вести полноценный хронологический журнал эксперимента: кто, когда и к какой сущности добавил заметку/комментарий.

**Модель данных**
1. `notes`:
- `id`, `experiment_id`, `author_id`, `title`, `body_md`, `created_at`, `updated_at`, `pinned`.
2. `note_links` (привязка к сущности):
- `note_id`, `entity_type` (`qualification_step|doe|run|report|task|experiment`), `entity_id`.
3. `note_comments` (обсуждение):
- `id`, `note_id`, `author_id`, `body_md`, `created_at`.
4. `note_tags` (опционально):
- Быстрые фильтры: `#defect`, `#machine`, `#recipe`, `#action-required`.

**Ключевое поведение**
1. Заметка может быть общей по эксперименту или привязанной к конкретной сущности.
2. В карточке сущности показывается блок “Журнал/Заметки” только по этой сущности + ссылка на общий журнал.
3. В карточке эксперимента должны отображаться все заметки связанные с экспериментом, помеченные сущностью в которой они были созданы
4. Таймлайн по датам: группировка `Сегодня / Вчера / Дата`.
5. Формат заметок: Markdown (заголовки, списки, чекбоксы, вложенные изображения/файлы по мере необходимости).
6. Экспорт в Обсидиан

**Календарный режим**
1. Месячный/недельный вид: точки активности по дням.
2. Клик по дате открывает список заметок, созданных/обновленных в этот день.
3. Фильтры календаря: по автору, сущности, тегу.

**Права и аудит**
1. Создавать: admin/manager/engineer.
2. Редактировать: автор, manager, admin.
3. Удалять: soft-delete только admin/manager.
4. Все правки заметок логируются (минимум: кто и когда редактировал).

**UI-минимум (первый релиз)**
1. Отдельная страница “Lab Journal” с непрерывной лентой заметок и боковой навигацией по точкам активности (по датам/якорям).
2. На странице эксперимента: панель должна появляться по клику на стрелку внизу экрана, она должна выплывать и быть заификисрована с низу(как терминал в ВС код) всота 80-85% со стрелкой вниз(чтобы скрыть). Меню должно выглдеть как чат с чатомГПТ, слева должена быть навигация в виде токих полосочек(как навигация у Грока) при наведении на которые будет показываться дата заметки. В будующей мобильной версии заметки будут выводиться свайпом вправо.

3. В этой панели можно быстро добавлять заметки “на лету”, без перехода на отдельную страницу.
4. Заголовок и метаданные заметки заполняются автоматически:
- `Эксперимент -> Сущность -> День -> Время -> Текст`.
- Сущность берется из текущего контекста (например, DOE, Run, Task, Qualification Step, Report).
- Дата и время берутся из серверного времени создания записи.
- автор - залогиненый пользователь
5. Минимальное меню форматирования в инпуте заметки:
- `bold`, `italic`, `bullet list`, `checklist`, `link`, `code`.
6. Каждое сообщение/заметка в панели показывает:
- авто-заголовок (эксперимент + сущность),
- timestamp,
- краткое тело заметки,
- ссылку “open in journal” для полного режима.

**Поведение правой панели в эксперименте**
1. По умолчанию панель открыта на desktop и сворачивается в иконку на mobile.
2. Фильтр “Только текущая сущность / Весь эксперимент”.
3. Быстрое переключение дней (Today, Yesterday, Date picker).
4. Sticky-позиционирование: панель остается видимой при прокрутке основной страницы.
5. Новые заметки появляются в ленте сразу после сохранения (optimistic update + sync с сервером).

**Этапы внедрения**
1. Этап 1: `notes` + Markdown + привязка к сущности + авто-метаданные + отдельная страница Journal.
2. Этап 2: правая плавающая панель `1/3` в эксперименте + быстрый ввод + live-лента.
3. Этап 3: комментарии и фильтры по дате/сущности/автору + боковая навигация по точкам.
4. Этап 4: календарный вид и уведомления о новых комментариях/упоминаниях.
5. Этап 5: экспорт журнала в report appendix (PDF/HTML).

**Статус (сделано сейчас)**
1. Реализован backend для заметок:
- `GET /experiments/:id/journal`
- `GET /experiments/:id/notes.json`
- `POST /experiments/:id/notes`
 - `POST /experiments/:id/notes/:noteId/delete` (soft-delete)
2. Добавлена отдельная страница `Lab Journal`:
- непрерывная лента заметок,
- левая навигация по точкам (с tooltip по времени),
- WYSIWYG-ввод с мини-тулбаром.
3. На странице эксперимента добавлена выезжающая нижняя панель заметок:
- открытие/скрытие по кнопке,
- быстрый ввод “на лету”,
- фильтр `Only current context`,
- ссылка `Open in journal`.
4. Единый notes UI подключен на сущностях:
- `experiment`, `qualification_step`, `doe`, `run`, `report`.
5. Добавлены цветовые метки сущностей (бейдж + цвет rail-точек).
6. Добавлены фильтры по тексту и дате.
7. Реализован режим дневной заметки:
- `Ctrl/Cmd + Enter` — дописать в текущую заметку дня (по сущности),
- `Ctrl/Cmd + Shift + Enter` — принудительно создать новую заметку.
8. Добавлены хлебные крошки для `/experiments/:id/journal`.

**Ближайшие шаги**
1. Довести верстку `Lab Journal` до стабильного desktop/mobile состояния.
2. Полноценный календарный вид на странице заметок (месяц + точки активности).
3. Группировка ленты по датам (`Сегодня / Вчера / Дата`) + быстрый переход по дню из календаря.
4. Комментарии к заметкам (`note_comments`) с правами на редактирование/soft-delete.
5. Визуальные стили типов заметок (severity / type / entity-driven styles).

**План на завтра (пошагово)**
1. `Journal layout cleanup`:
- выровнять header/toolbar/feed,
- убрать конфликтующие отступы и переполнения,
- проверить поведение drawer и journal на ширинах `1280/1024/768/390`.
2. `Calendar MVP` (только на странице `Lab Journal`):
- месяц с навигацией по месяцам,
- точки активности по дням,
- клик по дню => фильтр ленты по дате,
- кнопка сброса фильтра.
3. `Calendar + filters integration`:
- совместная работа `date + text search + entity filter`,
- корректный rail только по видимым заметкам.
4. `Acceptance checklist`:
- новая/дневная заметка всегда видна сразу в текущем списке,
- после дописывания дневной заметки обновляется время активности и позиция в ленте,
- soft-delete не ломает фильтры и rail,
- одинаковый UI на `experiment/step/doe/run/report`.

**Риски и как закрыть**
1. Риск: “шум” из коротких комментариев.
- Решение: разделить быстрые комментарии и полноценные заметки, добавить pin/priority.
2. Риск: потеря контекста при переносе сущностей.
- Решение: хранить `entity_type + entity_id`, а для архивных сущностей не удалять связь, а помечать `archived`.
3. Риск: слишком сложный UI.
- Решение: начать с одного списка + фильтров, календарь добавить вторым этапом.

## План миграции: `Editor.js` -> современный Markdown-редактор (Milkdown/Tiptap)

**Приоритет выполнения**
1. Сначала полностью заменить редактор отчетов на Markdown-редактор в режиме `WYSIWYG`.
2. Только после стабилизации отчетов переходить к реализации журнала/заметок.

**Выбор движка (на сейчас)**
1. Основной путь: `Tiptap` (V2 редактор отчетов).
2. Резервный путь: `Milkdown`, если не достигаем стабильного Markdown round-trip и экспорта.
3. Решение о смене принимается по техкритериям, а не по визуалу сайта.

**Цель**
- Перейти от блочной модели отчетов к единой Markdown-модели для отчетов, заметок и будущего экспорта (PDF/HTML/Obsidian) без потери исторических данных.

**Почему миграция нужна**
1. Сейчас отчеты хранятся как block-JSON (`report_documents.content_json`) и завязаны на набор блоков.
2. Для журнала, комментариев и длинных текстов нужна единая линейная модель документа.
3. Единый формат Markdown упростит экспорт, diff, versioning и reuse в мобильном клиенте.

**Целевой формат данных**
1. Добавить в `report_documents`:
- `content_md TEXT` (канонический формат),
- `content_html TEXT` (кеш рендера, опционально),
- `editor_kind TEXT` (`editorjs|milkdown|tiptap`),
- `schema_version INTEGER`.
2. На переходный период хранить оба формата:
- legacy `content_json` (Editor.js),
- новый `content_md`.

**Стратегия перехода (dual-run)**
1. Режим чтения:
- Если есть `content_md`, рендерим новый документ.
- Если нет `content_md`, рендерим legacy `content_json`.
2. Режим редактирования:
- Новые отчеты создавать сразу в новом редакторе.
- Старые отчеты оставить в legacy-режиме без конвертации на текущем этапе.
3. Подписи:
- Подписанный отчет остается read-only вне зависимости от редактора.

**Требования к редактору отчетов (V2)**
1. Режим редактирования: `WYSIWYG` по умолчанию, Markdown-source как дополнительный режим.
2. Полный набор инструментов:
- заголовки `H1-H4`,
- bold/italic/underline/strike,
- bullet/ordered/check list,
- таблицы, цитаты, code block, divider,
- ссылки, изображения, вложения,
- undo/redo, горячие клавиши.
3. Поддержка вставки из буфера (Word/Google Docs/HTML) с предсказуемой очисткой форматирования.
4. Стабильный экспорт в HTML/PDF из одного источника (`content_md` + renderer).
5. Read-only режим для подписанных отчетов без побочных действий сохранения.

**Критерии фейла для `Tiptap` (когда переключаемся на `Milkdown`)**
1. Потеря структуры при `md -> editor -> md` на типовых шаблонах отчетов.
2. Нестабильный экспорт PDF/HTML (регрессии по таблицам, спискам, изображениям).
3. Невозможность обеспечить паритет read-only/подписи в согласованный срок.

**Текущая граница этапа**
1. Конвертацию legacy-отчетов (`Editor.js JSON -> Markdown`) не делаем сейчас.
2. Причина: в системе пока нет накопленного массива готовых отчетов, ценность низкая.
3. Возврат к задаче конвертации: когда появятся реальные архивные отчеты, которые нужно переносить.

**Этапы внедрения**
1. Этап 1: подготовка БД и репозиториев под dual-format (`content_md`, `editor_kind`, `schema_version`).
2. Этап 2: внедрение V2 WYSIWYG-редактора для всех новых отчетов (feature flag `REPORT_EDITOR_V2`).
3. Этап 3: паритет функций с текущим редактором + стабилизация подписей и read-only.
4. Этап 4: стабилизация экспортов (PDF/HTML) из V2 и отключение создания новых legacy-документов.
5. Этап 5: review через 1-2 релиза, нужен ли вообще migration-конвертер.

**Критерии готовности**
1. 100% новых отчетов создаются в новом редакторе.
2. Подписанные отчеты корректно читаются и не теряют данные.
3. Экспорт PDF/HTML работает из `content_md` без регрессии по структуре.

**Риски и контроль**
1. Риск: расхождение рендера между old/new.
- Контроль: визуальный snapshot-тест ключевых секций.
2. Риск: двойная поддержка затянется.
- Контроль: решение по полной миграции принять после появления достаточного объема legacy-данных.

**Технический бэклог (коротко)**
1. `src/services/report_migration_service.ts`:
- `validateMarkdownReport`.
2. Роуты:
- новые роуты под V2-редактор (создание/сохранение/просмотр в markdown-режиме).
3. UI:
- бейдж типа редактора (`Legacy`/`Markdown`),
- без кнопки миграции на текущем этапе.

**Статус реализации (факт)**
1. Внедрен `Tiptap` на `/reports/:id/editor` вместо `Editor.js`.
2. Базовые требования соблюдены:
- `Save`, `Export PDF` (временный режим: `window.print()`), read-only для подписанных отчетов.
3. Реализован расширенный тулбар:
- заголовки, стили текста, списки, quote/code, align, ссылки, изображения, таблицы, divider, undo/redo.
4. Добавлены редакторские controls:
- выбор шрифта, размера, line-height, пресеты текста.
5. Реализован автосейв:
- debounce-сохранение при изменениях,
- дополнительное сохранение при blur/уходе со страницы.
6. Реализованы инструменты таблиц:
- вставка таблицы через сетку `rows x cols` (как в Word),
- операции `R+/R-/C+/C-/Del` с показом только в контексте таблицы.
7. Реализованы инструменты изображений:
- размер/выравнивание/удаление,
- controls видны только при выборе картинки.
8. Исправлены лимиты payload для сохранения больших документов/картинок (`body-parser` limit).
9. Добавлена безопасная поддержка inline-тегов (`sub/sup` и whitelist inline) в рендеринге отчета.

**Следующий этап (до `content_md`)**
1. Стабилизировать текущий редактор:
- прогнать регрессию по сохранению, подписям, печати/PDF на реальных отчетах.
2. Сделать полноценный PDF-режим:
- отдельные print-стили,
- корректные разрывы страниц,
- скрытие редакторных controls в печати.
3. Убрать остаточные UX-шероховатости:
- синхронизация всех toolbar-состояний,
- финальная мобильная компоновка тулбара.
4. После стабилизации перейти к каноническому хранению `content_md`:
- хранить `content_json + html_snapshot + content_md` на переходном этапе.

**Обновление статуса (`content_md`)**
1. Этап инициализирован:
- `report_documents` расширен полями `content_md`, `editor_kind`, `schema_version`.
2. Сохранение отчета уже пишет:
- `content_json`,
- `html_snapshot`,
- `content_md` (из HTML через markdown-конвертацию),
- `editor_kind='tiptap'`, `schema_version=1`.
3. Дальше:
- провести проверку качества markdown на 10-15 реальных отчетах,
- после валидации переключать экспорт на `content_md` как основной источник.

## Дополнение к roadmap: качество, управляемость и интеграции

**Цель**
- Повысить предсказуемость процесса, сократить время реакции на проблемы и подготовить систему к масштабированию (команда, площадки, внешние системы).

**Приоритетные инициативы**
1. **SPC-контур для run-данных**
- Контрольные карты (`Xbar-R`, `I-MR`) и алерты при выходе за контрольные пределы.
2. **Golden Run / Baseline-профили**
- Эталонные профили по `machine + recipe` и расчет отклонения текущих запусков от baseline.
3. **CAPA-процесс**
- Связка “дефект/аномалия -> задача -> corrective action -> проверка эффективности”.
4. **Tamper-evident аудит подписей**
- Хеш-снимок подписанного отчета и проверяемая цепочка изменений.
5. **Backup + Restore drill**
- Регулярный тест восстановления из бэкапа с фиксацией `RPO/RTO`.
6. **Уведомления и упоминания**
- `@mentions`, дедлайны задач, новые подписи/комментарии (in-app + email).
7. **Глобальный поиск**
- Полнотекстовый поиск по отчетам, заметкам, DOE, задачам с фильтрами.
8. **Версионирование рецептов и параметров машин**
- История версий с блокировкой “задним числом” для уже использованных конфигураций.
9. **Webhooks / Events API**
- События `task.updated`, `report.signed`, `run.completed` для интеграций (MES/ERP/LIMS).
10. **Quality Gates перед `Done`**
- Обязательные проверки: подписи, обязательные поля, минимальные run-критерии.

**Этапы внедрения**
1. **Quick wins (2-4 недели)**
- Quality Gates перед закрытием задач/экспериментов.
- Уведомления по дедлайнам и упоминаниям.
- Глобальный поиск (MVP: заголовки и метаданные).
- Backup + Restore drill (первый регламент и автоматическая проверка).
2. **Middle phase (1-2 релиза)**
- SPC-карты + базовые алерты по критичным метрикам.
- Golden Run и сравнение run против baseline.
- Полноценный CAPA-флоу с закрытием по критериям эффективности.
- Версионирование рецептов/параметров с привязкой к экспериментам.
3. **Long-term (после стабилизации core)**
- Tamper-evident журнал подписей и аудита.
- Webhooks / Events API для внешних систем.
- Расширенный поиск (full-text по телу Markdown и вложениям).

**Минимальные технические изменения**
1. БД:
- `notifications`, `mentions`, `quality_gates`, `baseline_profiles`, `capa_cases`, `audit_chain`, `recipe_versions`.
2. Сервисы:
- `src/services/spc_service.ts`,
- `src/services/notification_service.ts`,
- `src/services/capa_service.ts`,
- `src/services/audit_chain_service.ts`.
3. API:
- `/experiments/:id/quality-gates`,
- `/experiments/:id/spc`,
- `/tasks/:id/capa`,
- `/events/webhooks` (подпись webhook + retry policy).
4. Наблюдаемость:
- Метрики `alert_count`, `capa_lead_time`, `backup_restore_time`, `overdue_tasks`.

## План: внутренняя почта (Internal Mail) + интеграция с задачами и экспериментами

**Цель**
- Добавить асинхронную внутреннюю коммуникацию (по модели email/inbox) без realtime-чата.
- Связать сообщения с рабочими сущностями (`task`, `experiment`, `report`) и системными уведомлениями.

**Границы решения (осознанно без realtime)**
1. Нет WebSocket/чат-сокетов (`Socket.IO`, `ws` не требуются).
2. Обновление интерфейса через обычные HTTP-запросы и периодический refresh.
3. Приоритет: надежность, аудит, читаемая история обсуждений.

**Модель данных (MVP)**
1. `mail_threads`:
- `id`, `subject`, `created_by`, `context_type` (`experiment|task|report|system`), `context_id`, `created_at`, `updated_at`, `closed_at`.
2. `mail_messages`:
- `id`, `thread_id`, `author_id`, `body_md`, `created_at`, `edited_at`, `is_system`.
3. `mail_participants`:
- `thread_id`, `user_id`, `role` (`owner|participant|observer`), `muted`, `last_read_message_id`.
4. `mail_receipts`:
- `message_id`, `user_id`, `delivered_at`, `read_at`, `archived_at`, `deleted_at`.
5. `mail_attachments` (опционально 2-й этап):
- `id`, `message_id`, `file_path`, `file_name`, `mime`, `size`, `created_at`.

**Интеграция с основными сервисами**
1. Таски:
- При создании задачи — опционально автосоздание thread с `context_type=task`.
- События `task.assigned`, `task.overdue`, `task.status_changed` публикуются как системные сообщения в thread.
- Кнопка “Open task thread” в карточке задачи.
2. Эксперименты:
- Экспериментный thread (`context_type=experiment`) для общих обсуждений.
- События `experiment.status_changed`, `experiment.owner_changed`, `experiment.archived` пишутся как системные сообщения.
3. Отчеты/подписи:
- События `report.created`, `report.signed`, `report.rejected` создают запись в связанном thread.
4. Notifications:
- `notification_service` создает in-app уведомление со ссылкой на thread/message.
- Email (опционально): отправлять только дайджест/важные события, не каждое сообщение.

**API (минимум)**
1. `GET /mail/inbox` — список тредов пользователя (unread, updated_at, context).
2. `GET /mail/threads/:id` — просмотр треда + сообщения.
3. `POST /mail/threads` — создание треда (subject, participants, context).
4. `POST /mail/threads/:id/messages` — отправка сообщения.
5. `POST /mail/threads/:id/read` — отметить прочитанным до message_id.
6. `POST /mail/threads/:id/archive` — архивировать тред для пользователя.
7. `GET /tasks/:id/thread` и `GET /experiments/:id/thread` — быстрый переход к связанному треду.

**UI (MVP)**
1. Страница `Inbox`:
- вкладки `Unread`, `All`, `Archived`,
- сортировка по `updated_at`,
- фильтры по `context_type` и эксперименту.
2. Страница треда:
- лента сообщений (Markdown-render),
- индикатор системных сообщений,
- список участников,
- поле ответа + кнопка “Reply”.
3. Врезки в существующий UI:
- в `Task` и `Experiment` добавить кнопку/бейдж “Mail thread”.
- счетчик непрочитанных рядом с основным меню.

**Права доступа**
1. Создавать тред по задаче/эксперименту: `admin|manager|engineer`.
2. Писать в тред: участники треда + роли с доступом к сущности.
3. Чтение: только участники и пользователи с правом чтения контекстной сущности.
4. Удаление сообщений: soft-delete автором (ограниченное окно) и admin.

**Этапы внедрения**
1. Этап 1 (MVP):
- `mail_threads`, `mail_messages`, `mail_participants`, `mail_receipts`,
- `Inbox` + просмотр треда + отправка сообщений,
- интеграция с `task.assigned` и `experiment.status_changed`.
2. Этап 2:
- архив/поиск/фильтры,
- системные шаблоны сообщений по событиям report/task/experiment,
- in-app уведомления со ссылками на thread/message.
3. Этап 3:
- email-дайджесты (по расписанию или при high-priority событиях),
- вложения и экспорт переписки в report appendix (опционально).

**Риски и контроль**
1. Риск: дублирование с заметками (`Lab Journal`).
- Контроль: Journal = знания/хронология эксперимента, Mail = коммуникация и поручения.
2. Риск: шум от системных сообщений.
- Контроль: категории событий + mute на thread + daily digest.
3. Риск: потеря контекста при изменении/архивации сущности.
- Контроль: хранить `context_type/context_id` и snapshot заголовка сущности в момент публикации.
